From c6aad43a6446686df1ca90047050e49067a398cb Mon Sep 17 00:00:00 2001
From: Vincent Penquerc'h <vincent.penquerch@collabora.co.uk>
Date: Tue, 3 Jun 2014 15:10:33 +0100
Subject: [PATCH 15/21] alsasink: fix occasional crash intersecting invalid
 values

When a pipeline using alsasink and push mode upstream fails
to preroll, the following state will be the case:
- A loop upstream will be PAUSED, pushing a first buffer
- alsasink will be READY, pending PAUSED, because async

On error, the pipeline will switch to NULL. alsasink is in
READY, so goes to NULL immediately. It zeroes its cached
caps. Meanwhile, the upstream loop can cause a caps query,
conccurent with the state change. This will use those cached
caps. If the zeroing happens between the NULL test and the
dereferencing, GStreamer will critical down in the GstValue
code.

Since it appears that such a gap between states (PAUSED
and pushing upstream, and NULL downstream) is expected, we
need to protect the read/write access to the cached caps.

This fixes the critical.

See https://bugzilla.gnome.org/show_bug.cgi?id=731121
---
 ext/alsa/gstalsasink.c | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/ext/alsa/gstalsasink.c b/ext/alsa/gstalsasink.c
index 19dbd8bde..2dac98d2a 100644
--- a/ext/alsa/gstalsasink.c
+++ b/ext/alsa/gstalsasink.c
@@ -282,7 +282,9 @@ gst_alsasink_getcaps (GstBaseSink * bsink, GstCaps * filter)
   GstAlsaSink *sink = GST_ALSA_SINK (bsink);
   GstCaps *caps, *templ_caps;
 
+  GST_OBJECT_LOCK (sink);
   if (sink->handle == NULL) {
+    GST_OBJECT_UNLOCK (sink);
     GST_DEBUG_OBJECT (sink, "device not open, using template caps");
     return NULL;                /* base class will get template caps for us */
   }
@@ -291,20 +293,26 @@ gst_alsasink_getcaps (GstBaseSink * bsink, GstCaps * filter)
     if (filter) {
       caps = gst_caps_intersect_full (filter, sink->cached_caps,
           GST_CAPS_INTERSECT_FIRST);
+      GST_OBJECT_UNLOCK (sink);
       GST_LOG_OBJECT (sink, "Returning cached caps %" GST_PTR_FORMAT " with "
           "filter %" GST_PTR_FORMAT " applied: %" GST_PTR_FORMAT,
           sink->cached_caps, filter, caps);
       return caps;
     } else {
-      GST_LOG_OBJECT (sink, "Returning cached caps %" GST_PTR_FORMAT,
-          sink->cached_caps);
-      return gst_caps_ref (sink->cached_caps);
+      caps = gst_caps_ref (sink->cached_caps);
+      GST_OBJECT_UNLOCK (sink);
+      GST_LOG_OBJECT (sink, "Returning cached caps %" GST_PTR_FORMAT, caps);
+      return caps;
     }
   }
 
   element_class = GST_ELEMENT_GET_CLASS (sink);
   pad_template = gst_element_class_get_pad_template (element_class, "sink");
-  g_return_val_if_fail (pad_template != NULL, NULL);
+  if (pad_template == NULL) {
+    GST_OBJECT_UNLOCK (sink);
+    g_assert_not_reached ();
+    return NULL;
+  }
 
   templ_caps = gst_pad_template_get_caps (pad_template);
   caps = gst_alsa_probe_supported_formats (GST_OBJECT (sink), sink->device,
@@ -315,6 +323,8 @@ gst_alsasink_getcaps (GstBaseSink * bsink, GstCaps * filter)
     sink->cached_caps = gst_caps_ref (caps);
   }
 
+  GST_OBJECT_UNLOCK (sink);
+
   GST_INFO_OBJECT (sink, "returning caps %" GST_PTR_FORMAT, caps);
 
   if (filter) {
@@ -943,11 +953,13 @@ gst_alsasink_close (GstAudioSink * asink)
 {
   GstAlsaSink *alsa = GST_ALSA_SINK (asink);
 
+  GST_OBJECT_LOCK (asink);
   if (alsa->handle) {
     snd_pcm_close (alsa->handle);
     alsa->handle = NULL;
   }
   gst_caps_replace (&alsa->cached_caps, NULL);
+  GST_OBJECT_UNLOCK (asink);
 
   return TRUE;
 }
-- 
2.19.0

