From 5169918455e6c9064121be99fe80e1cd27c7da66 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?= <sebastian@centricular.com>
Date: Sat, 10 May 2014 09:14:33 +0200
Subject: [PATCH 03/12] flacdec: Add support for variable block size files and
 remove dead code

This dead code wasn't used since the 1.0 port and would need to
be modified heavily for variable block size support.

https://bugzilla.gnome.org/show_bug.cgi?id=729894
---
 ext/flac/gstflacdec.c | 45 ++++++-------------------------------------
 1 file changed, 6 insertions(+), 39 deletions(-)

diff --git a/ext/flac/gstflacdec.c b/ext/flac/gstflacdec.c
index 153748543..a303cdba5 100644
--- a/ext/flac/gstflacdec.c
+++ b/ext/flac/gstflacdec.c
@@ -332,14 +332,14 @@ gst_flac_calculate_crc8 (guint8 * data, guint length)
 /* FIXME: for our purposes it's probably enough to just check for the sync
  * marker - we just want to know if it's a header frame or not */
 static gboolean
-gst_flac_dec_scan_got_frame (GstFlacDec * flacdec, guint8 * data, guint size,
-    gint64 * last_sample_num)
+gst_flac_dec_scan_got_frame (GstFlacDec * flacdec, guint8 * data, guint size)
 {
   guint headerlen;
   guint sr_from_end = 0;        /* can be 0, 8 or 16 */
   guint bs_from_end = 0;        /* can be 0, 8 or 16 */
   guint32 val = 0;
   guint8 bs, sr, ca, ss, pb;
+  gboolean vbs;
 
   if (size < 10)
     return FALSE;
@@ -347,11 +347,8 @@ gst_flac_dec_scan_got_frame (GstFlacDec * flacdec, guint8 * data, guint size,
   /* sync */
   if (data[0] != 0xFF || (data[1] & 0xFC) != 0xF8)
     return FALSE;
-  if (data[1] & 1) {
-    GST_WARNING_OBJECT (flacdec, "Variable block size FLAC unsupported");
-    return FALSE;
-  }
 
+  vbs = ! !(data[1] & 1);       /* variable blocksize */
   bs = (data[2] & 0xF0) >> 4;   /* blocksize marker   */
   sr = (data[2] & 0x0F);        /* samplerate marker  */
   ca = (data[3] & 0xF0) >> 4;   /* channel assignment */
@@ -359,7 +356,8 @@ gst_flac_dec_scan_got_frame (GstFlacDec * flacdec, guint8 * data, guint size,
   pb = (data[3] & 0x01);        /* padding bit        */
 
   GST_LOG_OBJECT (flacdec,
-      "got sync, bs=%x,sr=%x,ca=%x,ss=%x,pb=%x", bs, sr, ca, ss, pb);
+      "got sync, vbs=%d,bs=%x,sr=%x,ca=%x,ss=%x,pb=%x", vbs, bs, sr, ca, ss,
+      pb);
 
   if (bs == 0 || sr == 0x0F || ca >= 0x0B || ss == 0x03 || ss == 0x07) {
     return FALSE;
@@ -406,36 +404,6 @@ gst_flac_dec_scan_got_frame (GstFlacDec * flacdec, guint8 * data, guint size,
     return FALSE;
   }
 
-  if (!last_sample_num)
-    return TRUE;
-
-  /* FIXME: This is can be 36 bit if variable block size is used,
-   * fortunately not encoder supports this yet and we check for that
-   * above.
-   */
-  val = (guint32) g_utf8_get_char_validated ((gchar *) data + 4, -1);
-
-  if (val == (guint32) - 1 || val == (guint32) - 2) {
-    GST_LOG_OBJECT (flacdec, "failed to read sample/frame");
-    return FALSE;
-  }
-
-  if (flacdec->min_blocksize == flacdec->max_blocksize) {
-    *last_sample_num = (val + 1) * flacdec->min_blocksize;
-  } else {
-    *last_sample_num = 0;       /* FIXME: + length of last block in samples */
-  }
-
-  /* FIXME: only valid for fixed block size streams */
-  GST_DEBUG_OBJECT (flacdec, "frame number: %" G_GINT64_FORMAT,
-      *last_sample_num);
-
-  if (flacdec->info.rate > 0 && *last_sample_num != 0) {
-    GST_DEBUG_OBJECT (flacdec, "last sample %" G_GINT64_FORMAT " = %"
-        GST_TIME_FORMAT, *last_sample_num,
-        GST_TIME_ARGS (*last_sample_num * GST_SECOND / flacdec->info.rate));
-  }
-
   return TRUE;
 }
 
@@ -796,8 +764,7 @@ gst_flac_dec_handle_frame (GstAudioDecoder * audio_dec, GstBuffer * buf)
 
     /* check if this is a flac audio frame (rather than a header or junk) */
     gst_buffer_map (buf, &map, GST_MAP_READ);
-    got_audio_frame =
-        gst_flac_dec_scan_got_frame (dec, map.data, map.size, NULL);
+    got_audio_frame = gst_flac_dec_scan_got_frame (dec, map.data, map.size);
     gst_buffer_unmap (buf, &map);
 
     if (!got_audio_frame) {
-- 
2.19.0

